// Simple Node.js server to handle file operations and API requests
const express = require('express');
const cors = require('cors');
const fs = require('fs').promises;
const path = require('path');
const fetch = require('node-fetch');
const yahooFinance = require('yahoo-finance2').default;

const app = express();
const PORT = 3000;
const DATA_DIR = path.join(__dirname, 'data');

// Data file paths
const DATA_FILES = {
    sp500: path.join(DATA_DIR, 'sp500_data.json'),
    treasury: path.join(DATA_DIR, 'treasury_data.json'),
    oil: path.join(DATA_DIR, 'oil_data.json'),
    gold: path.join(DATA_DIR, 'gold_data.json'),
    dollar: path.join(DATA_DIR, 'dollar_data.json')
};

// Middleware
app.use(cors());
app.use(express.json());
app.use(express.static(__dirname));

// FRED API Configuration
const FRED_API_KEY = '897749d57f5119292c49800a9d38d81c';
const FRED_API_BASE_URL = 'https://api.stlouisfed.org/fred/series/observations';

// Data source configuration
const DATA_SOURCES = {
    sp500: { type: 'fred', seriesId: 'SP500', name: 'S&P 500 Index' },
    treasury: { type: 'yahoo', symbol: 'TLT', name: 'Long-Duration Treasury ETF (TLT)' },
    oil: { type: 'fred', seriesId: 'DCOILWTICO', name: 'Crude Oil Prices: WTI' },
    gold: { type: 'yahoo', symbol: 'GC=F', name: 'Gold Futures' },
    dollar: { type: 'fred', seriesId: 'DTWEXAFEGS', name: 'Advanced Foreign Economies Dollar Index' }
};

// Ensure data directory exists
async function ensureDataDir() {
    try {
        await fs.mkdir(DATA_DIR, { recursive: true });
    } catch (error) {
        console.error('Error creating data directory:', error);
    }
}

// Helper function to fetch from FRED API
async function fetchFromFRED(seriesId, startDate = '1950-01-01') {
    const url = new URL(FRED_API_BASE_URL);
    url.searchParams.append('series_id', seriesId);
    url.searchParams.append('api_key', FRED_API_KEY);
    url.searchParams.append('file_type', 'json');
    url.searchParams.append('observation_start', startDate);

    const response = await fetch(url);

    // Handle rate limit
    if (response.status === 429) {
        throw new Error('FRED API rate limit exceeded (120 requests/minute). Please wait a moment.');
    }

    if (!response.ok) {
        throw new Error(`FRED API error! status: ${response.status}`);
    }

    const fredData = await response.json();
    const validData = fredData.observations.filter(obs => obs.value !== '.');

    return {
        dates: validData.map(obs => obs.date),
        values: validData.map(obs => parseFloat(obs.value))
    };
}

// Helper function to fetch from Yahoo Finance
async function fetchFromYahoo(symbol) {
    const endDate = new Date();
    const startDate = new Date();
    startDate.setFullYear(startDate.getFullYear() - 20); // Get 20 years of data

    const result = await yahooFinance.historical(symbol, {
        period1: startDate,
        period2: endDate,
        interval: '1d'
    });

    // Sort by date
    result.sort((a, b) => a.date - b.date);

    return {
        dates: result.map(item => item.date.toISOString().split('T')[0]),
        values: result.map(item => item.close)
    };
}

// Momentum comparison endpoint (MUST be before generic :indicator route)
app.get('/api/data/momentum', async (req, res) => {
    try {
        const indicators = ['sp500', 'treasury', 'oil', 'gold', 'dollar'];
        const momentumData = {};
        let successCount = 0;

        // Get baseline period from query parameter (default: 1m)
        const baselinePeriod = req.query.period || '1m';

        // Read all indicator data
        for (const indicator of indicators) {
            const filePath = DATA_FILES[indicator];
            try {
                const data = await fs.readFile(filePath, 'utf8');
                const jsonData = JSON.parse(data);

                console.log(`Processing ${indicator}: ${jsonData.dates.length} dates, baseline period: ${baselinePeriod}`);

                // Calculate momentum with specified baseline period
                const normalized = calculateMomentum(jsonData.dates, jsonData.values, baselinePeriod);

                console.log(`Normalized ${indicator}: ${normalized.dates.length} dates`);

                if (normalized.dates.length > 0) {
                    momentumData[indicator] = {
                        name: jsonData.name || DATA_SOURCES[indicator].name,
                        dates: normalized.dates,
                        values: normalized.values,
                        baselineDate: normalized.baselineDate
                    };
                    successCount++;
                } else {
                    console.log(`Warning: No normalized data for ${indicator}`);
                }
            } catch (error) {
                console.log(`No data available for ${indicator}: ${error.message}`);
            }
        }

        console.log(`Momentum data ready for ${successCount} indicators`);

        // Align all indicators to common dates
        if (successCount > 0) {
            // Find the common date range (intersection of all dates)
            const allDateSets = Object.values(momentumData).map(ind => new Set(ind.dates));
            const commonDates = [...allDateSets[0]].filter(date =>
                allDateSets.every(dateSet => dateSet.has(date))
            ).sort();

            console.log(`Common dates after alignment: ${commonDates.length}`);

            // Filter each indicator to only include common dates
            for (const indicator in momentumData) {
                const filtered = momentumData[indicator].dates.reduce((acc, date, idx) => {
                    if (commonDates.includes(date)) {
                        acc.dates.push(date);
                        acc.values.push(momentumData[indicator].values[idx]);
                    }
                    return acc;
                }, { dates: [], values: [] });

                momentumData[indicator].dates = filtered.dates;
                momentumData[indicator].values = filtered.values;
            }
        }

        res.json({
            success: successCount > 0,
            data: momentumData,
            count: successCount
        });

    } catch (error) {
        console.error('Error calculating momentum:', error);
        res.status(500).json({
            success: false,
            message: error.message
        });
    }
});

// Month-over-month growth rate endpoint (MUST be before generic :indicator route)
app.get('/api/data/growth', async (req, res) => {
    try {
        const indicators = ['sp500', 'treasury', 'oil', 'gold', 'dollar'];
        const growthData = {};
        let successCount = 0;

        // Read all indicator data
        for (const indicator of indicators) {
            const filePath = DATA_FILES[indicator];
            try {
                const data = await fs.readFile(filePath, 'utf8');
                const jsonData = JSON.parse(data);

                console.log(`Calculating growth for ${indicator}: ${jsonData.dates.length} dates`);

                // Calculate month-over-month growth rates
                const growth = calculateMonthOverMonthGrowth(jsonData.dates, jsonData.values);

                console.log(`Growth calculation for ${indicator}: ${growth.dates.length} months`);

                if (growth.dates.length > 0) {
                    growthData[indicator] = {
                        name: jsonData.name || DATA_SOURCES[indicator].name,
                        dates: growth.dates,
                        values: growth.values
                    };
                    successCount++;
                } else {
                    console.log(`Warning: No growth data for ${indicator}`);
                }
            } catch (error) {
                console.log(`No data available for ${indicator}: ${error.message}`);
            }
        }

        console.log(`Growth data ready for ${successCount} indicators`);

        res.json({
            success: successCount > 0,
            data: growthData,
            count: successCount
        });

    } catch (error) {
        console.error('Error calculating growth:', error);
        res.status(500).json({
            success: false,
            message: error.message
        });
    }
});

// Generic read local data file
app.get('/api/data/:indicator', async (req, res) => {
    const { indicator } = req.params;
    const filePath = DATA_FILES[indicator];

    if (!filePath) {
        return res.status(404).json({ success: false, message: 'Invalid indicator' });
    }

    try {
        const data = await fs.readFile(filePath, 'utf8');
        const jsonData = JSON.parse(data);
        res.json({ success: true, data: jsonData, source: 'local' });
    } catch (error) {
        // File doesn't exist or can't be read
        res.json({ success: false, message: 'No local data available', source: 'none' });
    }
});

// Generic refresh data from API and save locally
app.post('/api/data/:indicator/refresh', async (req, res) => {
    const { indicator } = req.params;
    const config = DATA_SOURCES[indicator];
    const filePath = DATA_FILES[indicator];

    if (!config || !filePath) {
        return res.status(404).json({ success: false, message: 'Invalid indicator' });
    }
    try {
        console.log(`Fetching ${config.name} from ${config.type.toUpperCase()}...`);

        let fetchedData;
        if (config.type === 'fred') {
            fetchedData = await fetchFromFRED(config.seriesId);
        } else if (config.type === 'yahoo') {
            fetchedData = await fetchFromYahoo(config.symbol);
        } else {
            throw new Error('Unknown data source type');
        }

        // Prepare data structure
        const dataToSave = {
            lastUpdated: new Date().toISOString(),
            indicator: indicator,
            name: config.name,
            source: config.type,
            sourceId: config.seriesId || config.symbol,
            dates: fetchedData.dates,
            values: fetchedData.values
        };

        // Save to local file
        await ensureDataDir();
        await fs.writeFile(filePath, JSON.stringify(dataToSave, null, 2));

        console.log(`${config.name} data saved successfully`);
        res.json({
            success: true,
            data: dataToSave,
            source: 'api',
            message: `Data fetched from ${config.type.toUpperCase()} and saved locally`
        });

    } catch (error) {
        console.error(`Error fetching/saving ${indicator} data:`, error);
        res.status(500).json({
            success: false,
            message: error.message
        });
    }
});

// Helper function to calculate momentum with adjustable baseline period
function calculateMomentum(dates, values, period = '1m') {
    if (!dates || !values || dates.length === 0) {
        console.log('calculateMomentum: No dates or values provided');
        return { dates: [], values: [], baselineDate: null };
    }

    const today = new Date();
    let targetDate;

    // Calculate baseline date based on period
    switch(period) {
        case '1m':
            // Last day of previous month
            targetDate = new Date(today.getFullYear(), today.getMonth(), 0);
            break;
        case '6m':
            // End of first month, 6 months ago
            targetDate = new Date(today.getFullYear(), today.getMonth() - 6, 0);
            break;
        case '1y':
            // End of first month, 1 year ago
            targetDate = new Date(today.getFullYear() - 1, today.getMonth(), 0);
            break;
        case '2y':
            // End of first month, 2 years ago
            targetDate = new Date(today.getFullYear() - 2, today.getMonth(), 0);
            break;
        case '3y':
            // End of first month, 3 years ago
            targetDate = new Date(today.getFullYear() - 3, today.getMonth(), 0);
            break;
        case '4y':
            // End of first month, 4 years ago
            targetDate = new Date(today.getFullYear() - 4, today.getMonth(), 0);
            break;
        case '5y':
            // End of first month, 5 years ago
            targetDate = new Date(today.getFullYear() - 5, today.getMonth(), 0);
            break;
        default:
            targetDate = new Date(today.getFullYear(), today.getMonth(), 0);
    }

    const baselineDate = targetDate.toISOString().split('T')[0];
    console.log(`Looking for baseline date (${period}): ${baselineDate}`);

    // Find the baseline value (closest date to or before last day of previous month)
    let baselineIndex = -1;
    let minDiff = Infinity;

    for (let i = 0; i < dates.length; i++) {
        const currentDate = new Date(dates[i]);
        const targetDate = new Date(baselineDate);
        const diff = targetDate - currentDate; // positive if current is before target

        // Find the closest date that is on or before the baseline date
        if (diff >= 0 && diff < minDiff) {
            minDiff = diff;
            baselineIndex = i;
        }
    }

    console.log(`Baseline index found: ${baselineIndex} (out of ${dates.length} dates)`);

    // If no baseline found before the target date, find the closest date after
    if (baselineIndex === -1) {
        console.log('No date before baseline found, looking for closest after...');
        for (let i = 0; i < dates.length; i++) {
            const currentDate = new Date(dates[i]);
            const targetDate = new Date(baselineDate);
            const diff = Math.abs(currentDate - targetDate);

            if (diff < minDiff) {
                minDiff = diff;
                baselineIndex = i;
            }
        }
    }

    // If still no baseline found, return empty
    if (baselineIndex === -1 || baselineIndex >= dates.length) {
        console.log('Could not find valid baseline index');
        return { dates: [], values: [] };
    }

    const baselineValue = values[baselineIndex];
    console.log(`Baseline value at ${dates[baselineIndex]}: ${baselineValue}`);

    // Normalize all values from baseline onwards to baseline = 100
    const normalizedDates = [];
    const normalizedValues = [];

    for (let i = baselineIndex; i < dates.length; i++) {
        normalizedDates.push(dates[i]);
        normalizedValues.push((values[i] / baselineValue) * 100);
    }

    console.log(`Normalized ${normalizedDates.length} data points`);

    return {
        dates: normalizedDates,
        values: normalizedValues,
        baselineDate: dates[baselineIndex]
    };
}

// Helper function to calculate month-over-month growth rate
function calculateMonthOverMonthGrowth(dates, values) {
    if (!dates || !values || dates.length === 0) {
        console.log('calculateMonthOverMonthGrowth: No dates or values provided');
        return { dates: [], values: [] };
    }

    // Group data by month and get the last value of each month
    const monthlyData = {};

    for (let i = 0; i < dates.length; i++) {
        const date = new Date(dates[i]);
        const yearMonth = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;

        // Keep the last value for each month
        if (!monthlyData[yearMonth] || dates[i] > monthlyData[yearMonth].date) {
            monthlyData[yearMonth] = {
                date: dates[i],
                value: values[i]
            };
        }
    }

    // Sort by year-month
    const sortedMonths = Object.keys(monthlyData).sort();

    console.log(`Found ${sortedMonths.length} months of data`);

    // Calculate month-over-month growth rates
    const growthDates = [];
    const growthValues = [];

    for (let i = 1; i < sortedMonths.length; i++) {
        const currentMonth = sortedMonths[i];
        const previousMonth = sortedMonths[i - 1];

        const currentValue = monthlyData[currentMonth].value;
        const previousValue = monthlyData[previousMonth].value;

        // Calculate percentage change
        const growthRate = ((currentValue - previousValue) / previousValue) * 100;

        growthDates.push(currentMonth);
        growthValues.push(growthRate);
    }

    console.log(`Calculated ${growthValues.length} month-over-month growth rates`);

    return {
        dates: growthDates,
        values: growthValues
    };
}

// Start server
app.listen(PORT, async () => {
    await ensureDataDir();
    console.log(`Server running at http://localhost:${PORT}`);
    console.log(`Data directory: ${DATA_DIR}`);
});